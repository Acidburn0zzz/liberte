#!/sbin/runscript

description="Sets up OTFE virtual partition."

depend() {
    # start after power management is enabled and drives were probed
    after laptop_mode smartd

    # use entropy for encrypted storage, if available
    use entropy

    # password entry is on console
    after  clock numlock gpm consolefont
    use    fbcondecor
    before xdm

    # Avoid ps-mount reloading autofs upon LVM partition attachment
    before autofs

    # Dependents wait indefinitely (important for parallel startup)
    keyword -timeout
}


# Prompt to print before password requests
eprompt() {
    local stars=`echo "$@" | sed 's/./-/g'`
    echo
    einfo "${stars}"
    einfo "$@"
    einfo "Keyboard map: `. /etc/conf.d/keymaps; echo \"${keymap}\" | tr '[:lower:]' '[:upper:]'`"
    einfo "${stars}"
    echo
}


# Variables
luser=anon
lgroup=legion
cuser=cable
cgroup=cable
lmount=/home/${luser}/persist
boot=/mnt/boot
live=/mnt/live
otfefile=${boot}${OTFEFILE}
ntfsflags=noatime,nosuid,nodev,compression,usermapping=/etc/ntfs-3g.map


start() {
    # Remount media root read-write (for non-loop/cd/dvd)
    remount=1
    cdtype=$(udevadm info -q property -p /dev/block/$(mountpoint -d ${boot}) 2>/dev/null | sed -n 's/^ID_FS_TYPE=//p')
    case "${cdtype}" in
    ''|unionfs|iso9660|udf)
        ewarn Skipping boot media read-write remount
        ;;
    *)
        ebegin Remounting ${boot} read-write
        mount -o remount,rw ${boot}
        remount=$?
        eend ${remount}
        ;;
    esac


    # Proceed with OTFE attachment only if remount-rw succeeded
    # (a read-only persist directory is more problematic than tmpfs)
    if [ ${remount} = 0 ]; then
        # Import splash functions (with an OpenRC compatibility hack)
        . /sbin/splash-functions.sh
        input_begin()   { splash svc_input_begin ${RC_SVCNAME}; }
        input_end()     { splash svc_input_end   ${RC_SVCNAME}; }


        # Add an OTFE line to /etc/fstab, so that autofs won't mount the LVM
        # device later, and for otfe-resize script to be able to mount it
        if ! grep -q "^/dev/mapper/${OTFEVOLUME} " /etc/fstab; then
            echo "/dev/mapper/${OTFEVOLUME} ${lmount} ntfs-3g noauto,${ntfsflags} 0 0" >> /etc/fstab
        fi

        # Initialize LUKS image mapping (create if it doesn't exist)
        if [ ! -e ${otfefile}  -o  -e ${otfefile}.tag ]; then
            mkdir -p -m 700 `dirname ${otfefile}`  &&  touch ${otfefile}.tag
            rm -f ${otfefile} ${otfefile}-hdr.bak

            # Round down to prevent problems with OTFESIZE=1
            freespace=$((`stat -fc '%a*%S' ${boot}`))
            otfesize=$((freespace * ${OTFESIZE} / (1024*1024)))

            #    3 MiB is the minimum possible size (rounded up to MiB)
            # 4095 MiB is the maximum possible file size on FAT32 (2^32-1 B)
            if [ ${otfesize} -lt 3 ]; then
                otfesize=3
            elif [ ${otfesize} -gt 4095 ]; then
                otfesize=4095
            fi

            # FAT has no sparse files, so insufficient space will fail here
            ebegin "Initializing ${otfesize} MiB encrypted storage (${OTFESIZE} of free space)"
            if [ -n "${otfesize}"  -a  -e ${otfefile}.tag ]  &&  truncate -s ${otfesize}M ${otfefile}; then
                loop=`losetup -f ${otfefile} --show`
                eend $?

                eprompt Please specify new password for ${otfefile}
                input_begin

                inittries=10
                while [ ${inittries} -ne 0 ] && ! cryptsetup -qy -c ${OTFECIPHER} -s ${OTFEKEYSIZE} -h ${OTFEHASH} luksFormat ${loop}; do
                    inittries=$((inittries-1))
                done

                if [ ${inittries} -ne 0 ]; then
                    echo
                    einfo 'OTFE initialized, run "sudo otfe-resize" to resize encrypted storage'

                    eprompt Please re-enter the password for ${otfefile}
                    if ! cryptsetup -T 100 luksOpen ${loop} ${OTFEVOLUME}; then
                        eerror Failed to attach encrypted storage, removing ${otfefile}
                        losetup -d ${loop}
                        rm ${otfefile}
                    else
                        rm ${otfefile}.tag
                    fi

                    input_end
                    echo

                    if [ ! -e ${otfefile}.tag ]; then
                        ebegin Backing up crypto header: ${otfefile}-hdr.bak
                        cryptsetup luksHeaderBackup --header-backup-file ${otfefile}-hdr.bak ${loop}
                        eend $?

                        # LC_ALL enables UTF-8 label support
                        ebegin Formatting encrypted storage as NTFS: ${otfefile}
                        LC_ALL=en_GB.UTF-8 mkntfs -q -f -C -I -L "${OTFELABEL}" -p 0 -H 0 -S 0 /dev/mapper/${OTFEVOLUME}
                        eend $?
                    fi
                else
                    losetup -d ${loop}
                    rm ${otfefile}

                    eerror Failed to initialize encrypted storage
                    input_end
                fi
            else
                rm -f ${otfefile}
                eend 1 "Failed to create ${otfesize} MiB encrypted storage"
            fi
        else
            eprompt Please provide a password for ${otfefile}
            input_begin

            loop=`losetup -f ${otfefile} --show`
            if ! cryptsetup -T 100 luksOpen ${loop} ${OTFEVOLUME}; then
                eerror Failed to attach encrypted storage: ${otfefile}
            fi

            input_end
            echo
        fi


        # Mount OTFE filesystem
        if [ -e /dev/mapper/${OTFEVOLUME} ]; then
            ebegin Mounting encrypted storage: ${lmount}
            mount ${lmount}
            eend $?
        fi

        # Verify directories and reset file permissions
        # NOTE: service fails if this verification fails
        if mountpoint -q ${lmount}; then
            ebegin Verifying persistence directories and permissions

            # newlines in filename are converted to \012 by getfacl
            getfacl -npsR ${lmount} | sed -n 's/^# file: //p' | xargs -rd '\n' setfacl -b --

            # similar to cp -an, but without unnecessary inode changes
            rsync -x -rlpgo --include='**/' --exclude='/**' ${live}${lmount}/ ${lmount}
            rsync -x -rlpgo --ignore-existing               ${live}${lmount}/ ${lmount}

            # ownership
            find ${lmount} -xdev -path ${lmount}/cables -prune -o \
                ! \( -user ${luser} -group ${lgroup} \) -print0   \
                | xargs -0r chown -h ${luser}:${lgroup} --
            find ${lmount}/cables -xdev -mindepth 2 ! \( -user ${cuser} -group ${cgroup} \) -print0 \
                | xargs -0r chown -h ${cuser}:${cgroup} --

            # permissions (sloppy w.r.t dirs, but rsync takes care of dirs that matter)
            find ${lmount} -xdev -perm /6007 -type d -print0 | xargs -0r chmod ug-s,o-rwx --
            find ${lmount} -xdev -path ${lmount}/security/cable -prune -o \
                -perm /7077 ! -type d ! -type l -print0 | xargs -0r chmod go=,u-s --

            # cables certs permissions
            find ${lmount}/security/cable -xdev ! -perm 710 -type d -print0 | xargs -0r chmod 710 --
            find ${lmount}/security/cable -xdev ! -perm 640 ! -type d ! -type l -print0 \
                | xargs -0r chmod 640 --

            eend $?
        fi

    else
        ewarn Skipping OTFE persistence setup
    fi
}


stop() {
    # Unmount the persistent fs
    if mountpoint -q ${lmount}; then
        ebegin Unmounting ${lmount}
        umount ${lmount}
        eend $?
    fi


    # Detach encrypted volume
    if cryptsetup status ${OTFEVOLUME} 1>/dev/null 2>&1; then
        ebegin Detaching encrypted storage
        cryptsetup luksClose ${OTFEVOLUME}
        losetup -d `losetup -j ${otfefile} | cut -d: -f1`
        eend $?

    fi


    # Remount media root read-only
    # (apparently, does not conflict with write cache)
    if mountpoint -q ${boot}; then
        ebegin Remounting ${boot} read-only
        mount -o remount,ro ${boot}
        eend $?
    fi
}
