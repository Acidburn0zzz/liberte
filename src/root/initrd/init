#!/bin/busybox ash

# Default variables
export PATH="/sbin:/bin"

# Bootstrap procedure (in /stage):
# mount /rwroot
# mount /boot
# mount /live   (from squashfs in /boot)
# move  /boot   -> /live/mnt/boot
# bind  /live   -> /live/mnt/live
# move  /rwroot -> /live/mnt/restrict/rwroot
# mount /union  (from /live/mnt/restrict/rwroot + /live)
# move  /union  -> /live/mnt/restrict/union
# bind  /live/mnt/restrict/union/{etc,var,tmp,home,root} -> /live/{...}
# switch_root to /live
stage=/stage

sboot=${stage}/boot
slive=${stage}/live
srwroot=${stage}/rwroot
sunion=${stage}/union

mboot=${slive}/mnt/boot
mlive=${slive}/mnt/live
mrwroot=${slive}/mnt/restrict/rwroot
munion=${slive}/mnt/restrict/union

mbinds="/etc /var /tmp /root /home"


# External scripts
. /etc/modules.fs
. /etc/init.scripts
# . /etc/init.splash


# Mount virtual filesystems
mount -t proc  proc  /proc
mount -t sysfs sysfs /sys

# Mount rwroot tmpfs directory
mount -t tmpfs -o mode=755 tmpfs ${srwroot}
mkdir -m 755 ${srwroot}/etc


# Parse kernel options
param_cdroot='/dev/sd* /dev/hd* /dev/sr* /dev/vd* /dev/ubd*'
param_cdroot_type=auto
param_cdroot_flags=noatime
for param in `cat /proc/cmdline`; do
    eval param_${param%%=*}=${param#*=}
done


# Specify required filesystem modules (no autoloading on mount)
# Load EHCI unconditionally, otherwise USB 1.1 might be forced if OHCI/UHCI comes up first
eval force_load=\"loop squashfs unionfs ehci-hcd \${force_load_"${param_cdroot_type}"}\"


# Handle uvesafb, and propagate options to rwroot
if [ "${param_video}" != "${param_video#uvesafb:}" ]; then
    vesa_mode=${param_video#uvesafb:}
    vesa_mode=${vesa_mode%%,*}

    echo "options uvesafb mode_option=${vesa_mode} mtrr=3 scroll=ywrap"
    force_load="${force_load} uvesafb"
else
    echo "blacklist uvesafb"
fi > /etc/modprobe.d/framebuffer.conf
cp -a /etc/modprobe.d ${srwroot}/etc


quiet_kmsg
good_msg 'Loading modules'

# Setup hotplugging before starting coldplugging
echo /bin/mdev > /proc/sys/kernel/hotplug

oldmods=
newmods=" ${force_load} "
while [ "${oldmods}" != "${newmods}" ]; do
    for modalias in ${newmods}; do
        if ! echo "${oldmods}" | grep -q " ${modalias} "; then
            modprobe -q ${modalias} 2>/dev/null
        fi
    done

    oldmods="${newmods}"
    newmods=' '$(cat $(find /sys/devices -name modalias) | sort -u | tr '\n' ' ')
done

# Start device manager
mdev -s


# Run debug shell if requested
rundebugshell


splash init


# No "udevadm settle" with mdev, so just loop
good_msg "Looking for the media"
tested=' '
waitmsg=0

while true; do
    if [ ${waitmsg} = 1 ]; then
        warn_msg 'Waiting for the media ...'
        waitmsg=0

        # Incorrect USB hubs? (VMWare)
        modprobe -q sd_mod      2>/dev/null
        modprobe -q usb-storage 2>/dev/null
    fi

    for mediadev in ${param_cdroot}; do
        # Check for a block device to mount
        if [ -b "${mediadev}" ] && ! echo "${tested}" | grep -q " ${mediadev} "; then
            tested="${tested}${mediadev} "

            # Skip if disk has at least one partition (heuristic)
            mediadevname=`basename ${mediadev}`
            if ! ls /sys/block/${mediadevname}/${mediadevname}[0-9]* 1>/dev/null 2>&1; then
                good_msg "Attempting to mount media: ${mediadev}"

                # Unless the media is already in ro mode, write-protect it during mount
                mediaro=`blockdev --getro ${mediadev} 2>/dev/null` || mediaro=1
                [ ${mediaro} == 1 ] || blockdev --setro ${mediadev}

                if mount -r -t ${param_cdroot_type} -o ${param_cdroot_flags} ${mediadev} ${sboot} >/dev/null 2>&1; then
                    # Check for the recognition file
                    if [ -e ${sboot}${param_loop} ]; then
                        good_msg "Media found on ${mediadev}"

                        [ ${mediaro} == 1 ] || blockdev --setrw ${mediadev}
                        break 2
                    else
                        umount ${sboot}
                    fi
                fi

                [ ${mediaro} == 1 ] || blockdev --setrw ${mediadev}
                waitmsg=1
            fi
        fi
    done

    sleep 0.5
done

test_success "find media to mount"


# Setup the loopback mounts and add fstab entries for fsck
if [ -n "${param_loop}" ]; then
    # CONFIG_FEATURE_DEVFS must be disabled for BusyBox
    good_msg 'Mounting squashfs filesystem'
    mount -r -t squashfs -o loop ${sboot}${param_loop} ${slive}
    test_success 'mount compressed filesystem'

    # Move boot mountpoint under live
    mount -o move ${sboot} ${mboot}

    echo "${mediadev} ${mboot#${slive}} ${param_cdroot_type} ro,${param_cdroot_flags} 0 1" > /etc/fstab.extra
    echo "${mboot#${slive}}${param_loop} / squashfs ro,loop 0 2"                          >> /etc/fstab.extra
else
    # Treat boot mountpoint as live mountpoint
    mount -o move ${sboot} ${slive}

    echo "${mediadev} / ${param_cdroot_type} ro,${param_cdroot_flags} 0 2" > /etc/fstab.extra
fi

# Bind extra live mountpoint under live
mount -r -o bind ${slive}   ${mlive}

# Move rwroot mountpoint under live
mount -o move    ${srwroot} ${mrwroot}


# Using ${slive} instead of ${mlive} hangs unionfs on ${slive}${sub} access
good_msg "Creating union mount"
mount -t unionfs -o dirs=${mrwroot}=rw:${mlive}=ro unionfs ${sunion}
test_success 'create union mount'

# Move union mountpoint under live
mount -o move ${sunion} ${munion}


# Bind rw union subtrees under live
for sub in ${mbinds}; do
    mount -r -o bind ${munion}${sub} ${slive}${sub}
    mount -o remount,rw,nosuid,nodev ${slive}${sub}
done


# Add useful lines to /etc/fstab
cat /etc/fstab.extra >> ${slive}/etc/fstab


# Run debug shell again if requested
rundebugshell


verbose_kmsg
good_msg 'Booting (initramfs)'
if [ ! -e ${slive}/dev/console  -o  ! -e ${slive}/dev/null ]; then
    bad_msg 'Real /dev is missing files required to boot (console and null)'
elif [ -e /etc/init.splash      -a  ! -e ${slive}/dev/tty1 ]; then
    bad_msg 'Real /dev is missing tty1, which is required for splash'
fi


# Disable mdev hotplug, and disable time change logging (hwclock starts before sysctl)
echo   > /proc/sys/kernel/hotplug
echo 0 > /proc/sys/kernel/grsecurity/timechange_logging
umount /sys  || bad_msg 'Failed to unmount /sys'
umount /proc || bad_msg 'Failed to unmount /proc'


cd ${slive}
exec switch_root -c /dev/console ${slive} /sbin/init


# If we get here, something bad has happened
splash verbose


echo 'A fatal error has probably occured since /sbin/init did not'
echo 'boot correctly. Trying to open a shell...'
exec sh
