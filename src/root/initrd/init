#!/bin/busybox ash

# Default variables
export PATH="/sbin:/bin"

union=/union
rwroot=/rwroot
boot=/mnt/boot
live=/mnt/live


# External scripts
. /etc/modules.fs
. /etc/init.scripts
# . /etc/init.splash


# Mount virtual filesystems
mount -t proc  proc  /proc
mount -t sysfs sysfs /sys

mount -t tmpfs -o mode=755 tmpfs ${union}
cp -a ${rwroot}/* ${union}
mount -o move ${union} ${rwroot}


# Parse kernel options
param_cdroot='/dev/sd* /dev/hd* /dev/sr* /dev/vd* /dev/ubd*'
param_cdroot_type=auto
param_cdroot_flags=noatime
for param in `cat /proc/cmdline`; do
    eval param_${param%%=*}=${param#*=}
done


# Specify required filesystem modules (no autoloading on mount)
# Load EHCI unconditionally, otherwise USB 1.1 might be forced if OHCI/UHCI comes up first
eval force_load=\"loop squashfs unionfs ehci-hcd \${force_load_"${param_cdroot_type}"}\"


# Handle uvesafb
if [ "${param_video}" != "${param_video#uvesafb:}" ]; then
    vesa_mode=${param_video#uvesafb:}
    vesa_mode=${vesa_mode%%,*}

    echo "options uvesafb mode_option=${vesa_mode} mtrr=3 scroll=ywrap"
    force_load="${force_load} uvesafb"
else
    echo "blacklist uvesafb"
fi > /etc/modprobe.d/framebuffer.conf
cp -a /etc/modprobe.d ${rwroot}/etc


quiet_kmsg
good_msg 'Loading modules'

# Setup hotplugging before starting coldplugging
echo /bin/mdev > /proc/sys/kernel/hotplug

oldmods=
newmods=" ${force_load} "
while [ "${oldmods}" != "${newmods}" ]; do
    for modalias in ${newmods}; do
        if ! echo "${oldmods}" | grep -q " ${modalias} "; then
            modprobe -q ${modalias} 2>/dev/null
        fi
    done

    oldmods="${newmods}"
    newmods=' '$(cat $(find /sys/devices -name modalias) | sort -u | tr '\n' ' ')
done

# Start device manager
mdev -s


# Run debug shell if requested
rundebugshell


splash init


# No "udevadm settle" with mdev, so just loop
good_msg "Looking for the media"
tested=' '
waitmsg=0

while true; do
    if [ ${waitmsg} = 1 ]; then
        warn_msg 'Waiting for the media ...'
        waitmsg=0

        # Incorrect USB hubs? (VMWare)
        modprobe -q sd_mod      2>/dev/null
        modprobe -q usb-storage 2>/dev/null
    fi

    for mediadev in ${param_cdroot}; do
        # Check for a block device to mount
        if [ -b "${mediadev}" ] && ! echo "${tested}" | grep -q " ${mediadev} "; then
            tested="${tested}${mediadev} "

            # Skip if disk has at least one partition (heuristic)
            mediadevname=`basename ${mediadev}`
            if ! ls /sys/block/${mediadevname}/${mediadevname}[0-9]* 1>/dev/null 2>&1; then
                good_msg "Attempting to mount media: ${mediadev}"

                # Unless the media is already in ro mode, write-protect it during mount
                mediaro=`blockdev --getro ${mediadev} 2>/dev/null` || mediaro=1
                [ ${mediaro} == 1 ] || blockdev --setro ${mediadev}

                if mount -r -t ${param_cdroot_type} -o ${param_cdroot_flags} ${mediadev} ${rwroot}${boot} >/dev/null 2>&1; then
                    # Check for the recognition file
                    if [ -e ${rwroot}${boot}${param_loop} ]; then
                        good_msg "Media found on ${mediadev}"

                        [ ${mediaro} == 1 ] || blockdev --setrw ${mediadev}
                        break 2
                    else
                        umount ${rwroot}${boot}
                    fi
                fi

                [ ${mediaro} == 1 ] || blockdev --setrw ${mediadev}
                waitmsg=1
            fi
        fi
    done

    sleep 0.5
done

test_success "find media to mount"


# Setup the loopback mounts and add fstab entries for fsck
if [ -n "${param_loop}" ]; then
    # CONFIG_FEATURE_DEVFS must be disabled for BusyBox
    good_msg 'Mounting squashfs filesystem'
    mount -r -t squashfs -o loop ${rwroot}${boot}${param_loop} ${rwroot}${live}
    test_success 'mount compressed filesystem'

    echo "${mediadev} ${boot} ${param_cdroot_type} ro,${param_cdroot_flags} 0 1" > /etc/fstab.extra
    echo "${boot}${param_loop} ${live} squashfs ro,loop 0 2"                    >> /etc/fstab.extra
else
    mount -o move ${rwroot}${boot} ${rwroot}${live}

    echo "${mediadev} ${live} ${param_cdroot_type} ro,${param_cdroot_flags} 0 2" > /etc/fstab.extra
fi


good_msg "Creating union mount"
mount -t unionfs -o dirs=${rwroot}=rw:${rwroot}${live}=ro unionfs ${union}
test_success 'create union mount'

# Move rwroot submounts to union (will be then adjusted after switch_root)
for mnt in $(cut -d' ' -f2 /proc/mounts | sed -n "s:^${rwroot}/:/:p"); do
    mount -o move ${rwroot}${mnt} ${union}${mnt}
done

# Move the rwroot mount to a hidden directory on union
# (rw layer directly accessible only by root)
mount -o move ${rwroot} ${union}/mnt/hidden${rwroot}


# Add useful lines to /etc/fstab
cat /etc/fstab.extra >> ${union}/etc/fstab


verbose_kmsg
good_msg 'Booting (initramfs)'
if [ ! -e ${union}/dev/console  -o  ! -e ${union}/dev/null ]; then
    bad_msg 'Real /dev is missing files required to boot (console and null)'
elif [ -e /etc/init.splash      -a  ! -e ${union}/dev/tty1 ]; then
    bad_msg 'Real /dev is missing tty1, which is required for splash'
fi


# Disable mdev hotplug, and disable time change logging (hwclock starts before sysctl)
echo   > /proc/sys/kernel/hotplug
echo 0 > /proc/sys/kernel/grsecurity/timechange_logging
umount /sys  || bad_msg 'Failed to unmount /sys'
umount /proc || bad_msg 'Failed to unmount /proc'


cd ${union}
exec switch_root -c /dev/console ${union} /sbin/init


# If we get here, something bad has happened
splash verbose


echo 'A fatal error has probably occured since /sbin/init did not'
echo 'boot correctly. Trying to open a shell...'
exec sh
