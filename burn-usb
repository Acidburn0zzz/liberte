#!/bin/bash -e

if [ $# != 2 ]; then
    cat <<EOF
This script writes a USB partition image on a USB device,
so that the partition is bootable, and is located after
a FAT32 partition. This makes the disk accessible under
Windows, and also provides persistent storage to LiveUSB.

You need the following installed:
    GNU Parted           2.x (Gentoo: sys-apps/parted)
    GNU GRUB Legacy      0.x (Gentoo: sys-boot/grub)
    DOS Filesystem Tools 3.x (Gentoo: sys-fs/dosfstools)

Run burnusb as root:
    burn-usb liveusb.img /dev/sdb

It is also possible to put the partition on a disk image,
such as VMWare disk, e.g. (you still need to be root):

    rm -f liveusb.vmdk liveusb-flat.vmdk
    vmware-vdiskmanager -c -a ide -t 2 -s 256MB liveusb.vmdk
    burn-usb liveusb.img liveusb-flat.vmdk

In addition, this script supports actual disk partitions as
a source:

    burn-usb /dev/sda2 /dev/sdb

All partitions will be 4K-aligned.

WARNING: All data on the target device will be lost!
EOF
    exit 1
fi

if [ ! -e $1 -o ! -e $2 ]; then
    echo "$1 or $2 doesn't exist."
    exit 1
fi

# Arguments
image="$1"
disk="$2"
partition=2
block=4096
doslabel=


# We need 512B MBR + e2fs_stage1_5 before the 1st partition,
# which is by covered the 32KiB DOS compatibility region
bootblocks=$[(32*1024 + ${block}-1) / ${block}]


# Get image size in 4K blocks (rounded up)
if [ -b "${image}" ]; then
    devtype=`udevadm info -q property -n "${image}" | grep '^DEVTYPE=' | cut -d= -f2`
    if [ -n "${devtype}" -a "${devtype}" != partition ]; then
        echo -e "WARNING: ${image} is a ${devtype}, not a partition"'!'"\n"
    fi

    imageblocks=$[(`blockdev --getsize64 "${image}"` + ${block}-1) / ${block}]
else
    imageblocks=`du --apparent-size -B ${block} "${image}" | cut -f1`
fi
echo "Image size:  $[${imageblocks} / (1024*1024 / ${block})]MiB"


# Get target device size in 4K blocks (rounded down)
if [ -b "${disk}" ]; then
    devpath=`udevadm info -q path -n "${disk}"`
    if [ -e "/sys/${devpath}/removable" ]; then
        if [ "`cat /sys/${devpath}/removable`" = 0 ]; then
            echo -e "WARNING: ${disk} is not a removable device"'!'"\n"
        fi
    fi

    devtype=`udevadm info -q property -n "${disk}" | grep '^DEVTYPE=' | cut -d= -f2`
    if [ -n "${devtype}" -a "${devtype}" != disk ]; then
        echo -e "WARNING: ${disk} is a ${devtype}, not a disk"'!'"\n"
    fi


    serial=`udevadm info -q property -n "${disk}" | grep '^ID_SERIAL=' | cut -d= -f2`
    if [ -n "${serial}" ]; then
        echo "Device ID:   ${serial}"
    fi

    diskblocks=$[`blockdev --getsz "${disk}"` / (${block} / 512)]
else
    diskblocks=$[`du -b "${disk}" | cut -f1` / ${block}]
fi
echo "Device size: $[${diskblocks} / (1024*1024 / ${block})]MiB"


# Sanity check: boot size + image size < target device size
if [ $[${bootblocks} + ${imageblocks}] -gt ${diskblocks} ]; then
    echo "ERROR: Source image won't fit on the target device"
    exit 1
fi


# User confirmation
cat <<EOF
Overwriting the disk with USB partition image.
WARNING: All data on the target device will be lost!

EOF

echo -e "\nContinue? [y/N] "
read confirm
case "${confirm}" in
y|Y|yes|YES|Yes)
    echo
    ;;
*)
    exit 1
esac


# Create new disk label, and get its size (in 4K blocks, rounded down) along the way
echo "*** Creating MSDOS partition label ***"
diskbytes=`parted -ms "${disk}" unit B mklabel msdos print | tail -1 | cut -d: -f2 | tr -d B`
if [ ${diskblocks} != $[${diskbytes} / ${block}] ]; then
    echo "ERROR: Disk size after partition creation is wrong"
    exit 1
fi


# The "-a" switch is available since GNU Parted 2.1, remove it otherwise
echo "*** Creating disk partitions ***"
parted -a minimal -s "${disk}" \
    unit   B \
    mkpart primary fat32 $[${bootblocks} * ${block}] $[(${diskblocks} - ${imageblocks}) * ${block} - 1] \
    mkpart primary ext2  $[(${diskblocks} - ${imageblocks}) * ${block}] $[${diskblocks} * ${block} - 1] \
    set    2 boot on \
    unit   kiB \
    print


if ! losetup -f 1>/dev/null 2>&1; then
    modprobe loop
    sleep 1
fi
loopdev=`losetup -f`


echo "*** Formatting FAT32 filesystem ***"
losetup -o $[${bootblocks} * ${block}] \
        -s $[(${diskblocks} - ${imageblocks} - ${bootblocks}) * ${block}] \
        -v ${loopdev} "${disk}"
mkdosfs -F 32 -n "${doslabel}" ${loopdev}
sleep 1
while ! losetup -d ${loopdev};  do echo "Retrying..."; sleep 1;  done


echo "*** Copying partition image ***"
losetup -o $[(${diskblocks} - ${imageblocks}) * ${block}] \
        -s $[${imageblocks} * ${block}] \
        -v ${loopdev} "${disk}"
dd if="${image}" of=${loopdev} bs=1M
while ! losetup -d ${loopdev};  do echo "Retrying..."; sleep 1;  done


# The (hd0) line in the bogus device prevents GRUB
# from performing BIOS drives detection
echo "*** Installing GRUB stages 1 and 1.5 ***"
grub --batch --no-floppy --device-map=<(echo "(hd0) /dev/null") <<EOF
device (hd0) ${disk}
root (hd0,$[${partition}-1])
setup (hd0)
quit
EOF


echo "*** Synchronizing ***"
sync
echo "*** Done ***"
